name: Droid Code Review

'on':
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: droid-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  contents: read
  issues: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Skip automated code review for draft PRs
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Validate workflow configuration
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          DROID_INSTALLER_SHA256: ${{ vars.DROID_INSTALLER_SHA256 }}
        run: |
          set -euo pipefail
          if [ -z "$FACTORY_API_KEY" ]; then
            echo "❌ FACTORY_API_KEY secret is not configured."
            echo "Add FACTORY_API_KEY in repository settings → Secrets and variables → Actions."
            exit 1
          fi

          if [ -z "${DROID_INSTALLER_SHA256:-}" ]; then
            echo "❌ DROID_INSTALLER_SHA256 repository variable is not configured."
            echo "Set vars.DROID_INSTALLER_SHA256 to the expected sha256 digest of the Droid CLI installer."
            exit 1
          fi

      - name: Restore Droid CLI cache
        id: cache-droid
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/bin/droid
            ~/.factory
          key: droid-cli-${{ vars.DROID_INSTALLER_SHA256 }}

      - name: Install prerequisites
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Install Droid CLI
        env:
          DROID_INSTALLER_SHA256: ${{ vars.DROID_INSTALLER_SHA256 }}
        run: |
          set -euo pipefail
          if ! command -v droid >/dev/null 2>&1; then
            curl -fsSL --compressed https://app.factory.ai/cli -o droid-cli-installer.sh
            echo "${DROID_INSTALLER_SHA256}  droid-cli-installer.sh" | sha256sum --check --status
            sh droid-cli-installer.sh
            rm -f droid-cli-installer.sh
          fi
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          "$HOME/.local/bin/droid" --version

      - name: Configure git identity
        run: |
          git config user.name "Droid Agent"
          git config user.email "droidagent@factory.ai"

      - name: Prepare review context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          fetch_paginated() {
            local url="$1"
            local output="$2"
            local page=1
            echo "[]" > "$output"

            while true; do
              local response
              response=$(curl -fsSL \
                -H "Authorization: token ${GH_TOKEN}" \
                -H "Accept: application/vnd.github.v3+json" \
                "${url}?per_page=100&page=${page}")

              if [ "$(echo "$response" | jq 'length')" -eq 0 ]; then
                break
              fi

              jq -s '.[0] + .[1]' "$output" <(echo "$response") > "${output}.tmp"
              mv "${output}.tmp" "$output"
              page=$((page + 1))
            done
          }

          # Get the PR diff
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git diff origin/${{ github.event.pull_request.base.ref }}...${{ github.event.pull_request.head.sha }} > diff.txt

          # Gather issue and review comments for deduplication
          fetch_paginated "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments" "existing_issue_comments.json"
          fetch_paginated "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/comments" "existing_review_comments.json"
          jq -s '.[0] + .[1]' existing_issue_comments.json existing_review_comments.json > existing_comments.json

          # Get changed files with patches for positioning
          curl -fsSL \
               -H "Authorization: token ${GH_TOKEN}" \
               -H "Accept: application/vnd.github.v3+json" \
               "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files?per_page=100" \
               > files_raw.json

          jq '[.[] | select(.patch != null) | {filename: .filename, patch: .patch}]' files_raw.json > files.json
          jq '[.[] | select(.patch == null) | .filename]' files_raw.json > truncated_files.json
          if [ "$(jq 'length' truncated_files.json)" -eq 0 ]; then
            rm -f truncated_files.json
          fi

      - name: Perform automated code review
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat > prompt.txt << 'EOF'
          You are an automated code review system. Review the PR diff and identify clear issues that need to be fixed.

          Input files (already in current directory):
          - diff.txt: the code changes to review
          - files.json: file patches with line numbers for positioning comments
          - existing_comments.json: skip issues already mentioned here
          - truncated_files.json (optional): files whose patches were truncated by GitHub; ignore these to avoid misaligned comments

          Task: Create a file called comments.json with this exact format:
          [{ "path": "path/to/file.js", "position": 42, "body": "Your comment here" }]

          Focus on these types of issues:
          - Dead/unreachable code (if (false), while (false), code after return/throw/break)
          - Broken control flow (missing break in switch, fallthrough bugs)
          - Async/await mistakes (missing await, .then without return, unhandled promise rejections)
          - Array/object mutations in React components or reducers
          - UseEffect dependency array problems (missing deps, incorrect deps)
          - Incorrect operator usage (== vs ===, && vs ||, = in conditions)
          - Off-by-one errors in loops or array indexing
          - Integer overflow/underflow in calculations
          - Regex catastrophic backtracking vulnerabilities
          - Missing base cases in recursive functions
          - Incorrect type coercion that changes behavior
          - Environment variable access without defaults or validation
          - Null/undefined dereferences
          - Resource leaks (unclosed files or connections)
          - SQL/XSS injection vulnerabilities
          - Concurrency/race conditions
          - Missing error handling for critical operations

          Comment format:
          - Clearly describe the issue: "This code block is unreachable due to the if (false) condition"
          - Provide a concrete fix: "Remove this entire if block as it will never execute"
          - When possible, suggest the exact code change:
            ```suggestion
            // Remove the unreachable code
            ```
          - Be specific about why it's a problem: "This will cause a TypeError if input is null"
          - No emojis, just clear technical language

          Skip commenting on:
          - Code style, formatting, or naming conventions
          - Minor performance optimizations
          - Architectural decisions or design patterns
          - Features or functionality (unless broken)
          - Test coverage (unless tests are clearly broken)

          Position calculation:
          - Use the "position" field from files.json patches
          - This is the line number in the diff, not the file
          - Comments must align with exact changed lines only

          Output:
          - Empty array [] if no issues found
          - Otherwise array of comment objects with path, position, body
          - Each comment should be actionable and clear about what needs to be fixed
          - Maximum 10 comments total; prioritize the most critical issues

          CRITICAL: Ensure the comments.json file contains valid JSON that can be parsed by JSON.parse().
          - All strings in JSON must be properly escaped
          - Use \\n for newlines in body strings
          - Use \\\" for quotes in strings
          - Use \\\\ for backslashes
          - Use \\t for tabs
          - No unescaped newlines, quotes, backslashes, or control characters in the JSON text
          - Test your JSON by running: python3 -m json.tool comments.json
          - The JSON must be a single line without line breaks within string values
          EOF

          # Run droid exec with the prompt
          echo "Running code review analysis..."
          droid exec -f prompt.txt --skip-permissions-unsafe || {
            echo "❌ ERROR: droid exec failed"
            echo "This could be due to missing FACTORY_API_KEY or other runtime issues."
            exit 1
          }

          # Check if comments.json was created
          if [ ! -f comments.json ]; then
            echo "❌ ERROR: droid exec did not create comments.json"
            echo "This usually indicates the review run failed (e.g. missing FACTORY_API_KEY or runtime error)."
            exit 1
          fi

          echo "=== Review Results ==="
          cat comments.json

          # Validate JSON before proceeding
          echo "Validating JSON format..."
          if ! python3 -m json.tool comments.json > /dev/null 2>&1; then
            echo "❌ ERROR: Invalid JSON in comments.json"
            echo "Content that failed validation:"
            cat comments.json
            echo ""
            echo "This usually means the AI generated unescaped characters in the comment body."
            echo "Creating a fallback empty comments.json to allow the workflow to continue..."
            echo "[]" > comments.json
          fi
          echo "✅ JSON validation passed"

      - name: Sanitize review comments
        run: |
          set -euo pipefail
          if [ ! -f comments.json ]; then
            exit 0
          fi

          python3 <<'PY'
          import json
          import os
          from pathlib import Path

          path = Path("comments.json")
          try:
            data = json.loads(path.read_text())
          except json.JSONDecodeError:
            raise SystemExit("comments.json is not valid JSON after validation step.")

          if not isinstance(data, list):
            path.write_text("[]")
            raise SystemExit("comments.json payload was not a list; cleared for safety.")

          max_len = 65000
          cleaned = []
          seen = set()

          for entry in data:
            if not isinstance(entry, dict):
              continue
            file_path = entry.get("path")
            position = entry.get("position")
            body = entry.get("body")
            if not file_path or position is None or body is None:
              continue

            body = str(body).replace("\r", "").strip()
            if not body:
              continue

            if len(body) > max_len:
              body = body[: max_len - 3] + "..."

            key = (file_path, position, body)
            if key in seen:
              continue

            seen.add(key)
            cleaned.append({"path": file_path, "position": position, "body": body})

          path.write_text(json.dumps(cleaned, separators=(",", ":")))
          PY

      - name: Submit inline review comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const prNumber = context.payload.pull_request.number;
            const NO_ISSUES_MARKER = '<!-- droid-review:no-issues -->';

            if (!fs.existsSync('comments.json')) {
              core.info('comments.json missing; skipping review submission');
              return;
            }

            const commentsContent = fs.readFileSync('comments.json', 'utf8');
            let comments;
            try {
              comments = JSON.parse(commentsContent);
            } catch (error) {
              core.error('Failed to parse comments.json: ' + error.message);
              core.error('JSON content: ' + commentsContent);
              throw new Error('Invalid JSON in comments.json: ' + error.message);
            }

            const existingReviews = await github.paginate(github.rest.pulls.listReviews, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });

            if (!Array.isArray(comments) || comments.length === 0) {
              const hasNoIssuesComment = existingReviews.some(review => (review.body || '').includes(NO_ISSUES_MARKER));

              if (!hasNoIssuesComment) {
                const payload = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  event: 'COMMENT',
                  body: `✅ No issues found in the current changes.\n\n${NO_ISSUES_MARKER}`
                };

                for (let attempt = 1; attempt <= 3; attempt++) {
                  try {
                    await github.rest.pulls.createReview(payload);
                    break;
                  } catch (error) {
                    if (attempt === 3) {
                      throw error;
                    }
                    core.warning(`createReview attempt ${attempt} failed: ${error.message}. Retrying...`);
                    await sleep(attempt * 2000);
                  }
                }
              }
              return;
            }

            const existingReviewComments = await github.paginate(github.rest.pulls.listReviewComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });

            const existingKeys = new Set(
              existingReviewComments.map(comment => {
                const path = comment.path || '';
                const position = comment.position ?? comment.original_position ?? '';
                const body = (comment.body || '').trim();
                return `${path}::${position}::${body}`;
              })
            );

            const filtered = comments
              .map(entry => ({
                path: entry.path,
                position: entry.position,
                body: typeof entry.body === 'string' ? entry.body.trim() : ''
              }))
              .filter(entry => {
                if (!entry.path || typeof entry.position !== 'number' || !entry.body) {
                  return false;
                }
                const key = `${entry.path}::${entry.position}::${entry.body}`;
                return !existingKeys.has(key);
              });

            if (filtered.length === 0) {
              core.info('All proposed comments already exist; skipping new review submission.');
              return;
            }

            const summary = `Found ${filtered.length} potential issue${filtered.length === 1 ? '' : 's'} that should be addressed.`;
            const payload = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              event: 'COMMENT',
              body: `${summary}\n\n${NO_ISSUES_MARKER}`,
              comments: filtered
            };

            for (let attempt = 1; attempt <= 3; attempt++) {
              try {
                await github.rest.pulls.createReview(payload);
                core.info(`Submitted review with ${filtered.length} inline comments`);
                break;
              } catch (error) {
                if (attempt === 3) {
                  throw error;
                }
                core.warning(`createReview attempt ${attempt} failed: ${error.message}. Retrying...`);
                await sleep(attempt * 2000);
              }
            }

      - name: Upload debug artifacts on failure
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: droid-review-debug-${{ github.run_id }}
          path: |
            diff.txt
            files.json
            existing_comments.json
            prompt.txt
            comments.json
          if-no-files-found: ignore
          retention-days: 7

      - name: Log completion status
        if: always()
        run: |
          echo "=== Code Review Workflow Summary ==="
          if [ -f comments.json ]; then
            echo "✅ comments.json created successfully"
            echo "File size: $(wc -c < comments.json) bytes"
            echo "Number of comments: $(python3 -c "import json; print(len(json.load(open('comments.json'))))" 2>/dev/null || echo "Invalid JSON")"
          else
            echo "❌ comments.json was not created"
          fi
          echo "Workflow completed at $(date)"
