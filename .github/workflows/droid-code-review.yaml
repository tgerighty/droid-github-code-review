name: Droid Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number

concurrency:
  group: droid-review-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  contents: read
  issues: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.draft == false

    steps:
      - name: Set PR number
        id: pr-number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "number=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check API keys
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          MODEL_API_KEY: ${{ secrets.MODEL_API_KEY }}
        run: |
          if [ -z "$FACTORY_API_KEY" ]; then
            echo "Error: FACTORY_API_KEY is missing"
            exit 1
          fi
          if [ -z "$MODEL_API_KEY" ]; then
            echo "Error: MODEL_API_KEY is missing"
            exit 1
          fi

      - name: Install Droid CLI
        env:
          DROID_INSTALLER_SHA256: ${{ vars.DROID_INSTALLER_SHA256 }}
        run: |
          if [ ! -f "$HOME/.local/bin/droid" ]; then
            curl -fsSL --connect-timeout 10 --max-time 60 https://app.factory.ai/cli -o droid-cli-installer.sh
            timeout 120 sh droid-cli-installer.sh || {
              echo "Error: Droid CLI installation timed out"
              exit 1
            }
          fi
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Configure custom model
        env:
          MODEL_API_KEY: ${{ secrets.MODEL_API_KEY }}
        run: |
          mkdir -p "$HOME/.factory"
          cat > "$HOME/.factory/config.json" << 'EOF'
          {
            "custom_models": [
              {
                "model_display_name": "GLM-4.6 [Z.AI]",
                "model": "GLM-4.6",
                "base_url": "https://api.z.ai/api/coding/paas/v4",
                "api_key": "MODEL_API_KEY_PLACEHOLDER",
                "provider": "generic-chat-completion-api",
                "max_tokens": 131072
              }
            ]
          }
          EOF
          jq --arg key "$MODEL_API_KEY" '.custom_models[0].api_key = $key' "$HOME/.factory/config.json" > "$HOME/.factory/config.json.tmp"
          mv "$HOME/.factory/config.json.tmp" "$HOME/.factory/config.json"

      - name: Test droid exec
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
        run: |
          echo "Testing droid exec with custom:GLM-4.6 model..."
          droid exec "hello world" --model custom:GLM-4.6

      - name: Perform automated code review
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr-number.outputs.number }}
        run: |
          cat > prompt.txt << EOF
          You are an automated code review system. Review PR diff and identify clear issues that need to be fixed.

          CRITICAL ISSUES (must fix):
          - Security vulnerabilities (SQL/XSS injection, insecure deserialization, path traversal)
          - Resource leaks (unclosed files, connections, event listeners, memory leaks)
          - Null/undefined dereferences that will cause runtime errors
          - Dead/unreachable code (if (false), while (false), code after return/throw/break)
          - Race conditions in async/parallel code
          - Integer overflow/underflow in calculations
          - Missing error handling for critical operations (file I/O, network, database)
          
          HIGH PRIORITY ISSUES:
          - Performance bottlenecks (N+1 queries in loops, inefficient algorithms, missing caching)
          - Broken control flow (missing break in switch, fallthrough bugs, infinite loops)
          - Async/await mistakes (missing await, unhandled promise rejections, race conditions)
          - Off-by-one errors in loops or array indexing
          - Incorrect type coercion that changes behavior
          - UseEffect dependency array problems (missing deps, incorrect deps, infinite re-renders)
          - Array/object mutations in React components or reducers
          
          MEDIUM PRIORITY ISSUES:
          - SOLID principle violations (Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion)
          - Architectural issues (circular dependencies, god objects, tight coupling)
          - Code quality violations (deep nesting, long functions, magic numbers/strings)
          - Duplicate code (DRY violations)
          - Missing or poor documentation for complex logic
          - Hard-coded values that should be configurable
          
          LOW PRIORITY ISSUES:
          - Inconsistent naming conventions
          - Missing modern JavaScript patterns (destructuring, arrow functions, array methods)
          - Suboptimal but functional code
          - Minor code style improvements

          CONTEXT ANALYSIS:
          - Determine if PR is bug fix, new feature, refactor, or breaking change
          - Consider impact on existing systems and backward compatibility
          - Evaluate complexity vs benefit ratio for suggested changes
          - Check if changes follow established patterns in codebase

          IMPROVEMENT STRATEGY:
          - For CRITICAL issues: Must be fixed before merge
          - For HIGH issues: Strongly recommend fixing, may block merge
          - For MEDIUM issues: Recommend fixing when time permits
          - For LOW issues: Optional improvements, note in comments
          - Always provide concrete, testable suggestions
          - Consider effort vs impact when prioritizing fixes

          Output format:
          - Empty array [] if no issues found
          - Otherwise array of comment objects with path, position, body
          - Each comment should include priority indicator in body:
            "CRITICAL: [issue description]"
            "HIGH: [issue description]"
            "MEDIUM: [issue description]"
            "LOW: [issue description]"
          - Comments must be actionable and clear about what needs to be fixed
          - ${MAX_COMMENTS_TEXT}; prioritize by CRITICAL > HIGH > MEDIUM > LOW

          CRITICAL: Ensure comments.json file contains valid JSON that can be parsed by JSON.parse().
          - All strings in JSON must be properly escaped
          - Use \n for newlines in body strings
          - Use \\" for quotes in strings
          - Use \\\\ for backslashes
          - Use \\t for tabs
          - No unescaped newlines, quotes, backslashes, or control characters in JSON text
          - Test your JSON by running: python3 -m json.tool comments.json
          EOF

          # Get PR data and run review
          echo "Running comprehensive code review..."
          echo "PR Number: $PR_NUMBER"
          echo "Fetching PR data..."
          curl -fsSL -H "Authorization: token $GH_TOKEN" \\
               "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER" \\
               | jq '.diff' > diff.txt

          echo "Fetching PR files..."
          curl -fsSL -H "Authorization: token $GH_TOKEN" \\
               "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files" \\
               | jq '[.[] | select(.patch != null) | {filename: .filename, patch: .patch}]' > files.json

          echo "Fetching existing comments..."
          curl -fsSL -H "Authorization: token $GH_TOKEN" \\
               "https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \\
               | jq '[.]' > existing_comments.json

          echo "Running droid analysis..."
          droid exec -f prompt.txt --model custom:GLM-4.6 --output json > results.json || {
            echo "âŒ ERROR: droid analysis failed"
            echo "This could be due to missing API keys or runtime issues."
            exit 1
          }

          echo "Posting comments to PR..."
          node -e "
          const fs = require('fs');
          const results = JSON.parse(fs.readFileSync('results.json', 'utf8'));
          const existing = JSON.parse(fs.readFileSync('existing_comments.json', 'utf8'));
          
          // Filter out already mentioned issues
          const filtered = results.filter(comment => {
            return !existing.some(existing => 
              existing.body.includes(comment.body.split(':')[1]) && 
              existing.path === comment.path
            );
          });
          
          console.log('Posting', filtered.length, 'new comments');
          
          if (filtered.length > 0) {
            filtered.forEach(async (comment, index) => {
              const response = await fetch('https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/comments', {
                method: 'POST',
                headers: {
                  'Authorization': 'token $GH_TOKEN',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(comment)
              });
              
              if (!response.ok) {
                console.error('Failed to post comment:', await response.text());
              } else {
                console.log('Posted comment', index + 1);
              }
              
              // Rate limiting
              if (index < filtered.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            });
          }"
